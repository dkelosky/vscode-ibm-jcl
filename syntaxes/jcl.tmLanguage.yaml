---
"$schema": https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json

# https://macromates.com/manual/en/language_grammars#naming-conventions
# https://macromates.com/manual/en/appendix#property-list-format
# https://github.com/PanAeon/vscode-tmgrammar-test
# https://srinimf.com/2017/12/08/jcl-three-popular-ideas-to-continuation/

name: Job Control Language
patterns:
  - include: "#jcl_syntax"
repository:
  jcl_syntax:
    patterns:
      # The first found match applies.  For example, if line matches on `#lineTooLong`,
      # it's highlighting attributes are set.
      - include: "#lineTooLong"
      - include: "#lineComment"
      - include: "#parseLine"
      - include: "#jclLineStart"

  additionaljclHighlight:
    patterns:
      - include: "#operators"
      - include: "#numbers"
      - include: "#variables"

  #
  # Handles basic syntax error cases
  #
  lineTooLong:
    # TODO(Kelosky): this probably isn't true for all JCL, especially for //SYSIN
    # content sent through z/OSMF.
    patterns:
      - name: invalid.illegal.jcl #red
        match: ^.{81,}

  #
  # Handle comments - all statements that have a `//*` in column 1
  #
  lineComment:
    patterns:
      # First, if `//*` and 69 characters follow and 8 more treat as comment and sequence
      - match: (\/\/\*.{69,69})(.*)
        name: comment.line.double-slash.jcl #green
        captures:
          1:
            name: comment.line.double-slash.jcl
          2:
            patterns:
              - include: "#sequenceNumbers"
      # Else, treat entire line as comment
      - match: \/\/\*.*
        name: comment.line.double-slash.jcl

  #
  # Handle a line with and without sequence numbers
  #
  parseLine:
    patterns:
      # parse off line of JCL and sequence numbers
      - match: (.{72,72})(.{0,8})
        captures:
          1:
            # line of JCL
            patterns:
              - include: "#jclLineStart"
          2:
            # sequence numbers
            patterns:
              - include: "#sequenceNumbers"

  #
  # Handle a line of JCL
  #
  jclLineStart:
    patterns:
      - include: "#inlineDD"
      - include: "#conditionals"
      - include: "#continuation"
      - include: "#jclLineReuse"

  jclLineReuse:
    patterns:
      - match: ([^*]\S*)?\s+(.*)
        captures:
          1:
            # The label for a line.
            patterns:
              - include: "#labels"
          2:
            # The statement
            patterns:
              - include: "#jclStatement"

  jclLineContinued:
      patterns:
      - match: (\/\/)(\s+)(.*)
        captures:
          1:
            # The label for a line.
            patterns:
              - include: "#labels"
          3:
            # The statement
            patterns:
              - include: "#jclArguments"

  #
  # Handle inline DD
  #
  inlineDD:
      patterns:
        # Match DD * and parms
        - begin: ([^*]\S*)?\s+(DD\s+\*\S*?)\s(.*)
          end: (.*)(^\/\*)(.*)
          beginCaptures:
            1:
              # name: entity.name.function.jcl
              patterns:
                - include: "#labels"
            2:
              name: keyword.other.jcl
            3:
              name: comment.line.double-slash.jcl
          endCaptures:
            1:
              patterns:
                - match: (\/\/)?(.*)
                  captures:
                    1:
                      patterns:
                        - include: "#labels"
                    2:
                      name: variable.parameter.jcl
            2:
              name: keyword.other.jcl
            3:
              name: comment.line.double-slash.jcl
          contentName: string.quoted.other.jcl

  #
  # Handle IF THEN conditionals
  #
  conditionals:
    patterns:
      - begin: ([^*]\S*)?\s+(IF)\s
        end: (.*)(THEN)(.*)

          # - match: .*
          #   name: variable.parameter.jcl
        beginCaptures:
          1:
            # name: entity.name.function.jcl
            patterns:
              - include: "#labels"
          2:
            name: keyword.other.jcl
        endCaptures:
          1:
            patterns:
              - match: (\/\/)?(.*)
                captures:
                  1:
                    patterns:
                      - include: "#labels"
                  2:
                        name: variable.parameter.jcl
          2:
            name: keyword.other.jcl #dark blue
          3:
            name: comment.line.double-slash.jcl
        contentName: variable.parameter.jcl

  #
  # Handle continuation
  #
  continuation:
    patterns:
      # begin and end of line assertions actually matter here
      - begin: ^(([^*]\S*)?\s+(\S+)\s+.*,)$
        end: (\/\/)(\s+)(\S+[^,]\s+.*)
        # patterns here must be an include and cannot
        # specify a direct match / name
        patterns:
          - include: "#jclLineContinued"
        beginCaptures:
          1:
            patterns:
              - include: "#jclLineReuse"
        endCaptures:
          1:
            patterns:
              - include: "#labels"
          3:
            patterns:
              - include: "#jclArguments"

        # it is not clear how contentName comes into play when
        # patterns are also used here.
        # contentName: invalid.illegal.jcl

  jclStatement:
    #  A simple source statement with 3 things. A statement,
    #  parameters, and comment
    patterns:
      - match: (\S+)\s*(.*)
        captures:
          1:
            name: keyword.other.jcl #darkblue
          2:
            patterns:
              - include: "#jclArguments"

  jclArguments:
    patterns:
      - include: "#stringType"
      # Handle no strings in statement
      - match: (\S*)(.*)
        captures:
          1:
            # This group refers to an statement operator
            name: keyword.control.jcl #purple
            patterns:
              - include: "#additionaljclHighlight"
          2:
            # The rest of the line is a comment.
            name: comment.line.double-slash.jcl

  variables:
    patterns:
      - match: ([&%?])(?!=\1)(.{,8}?)(\.?)((?=\W)|$)
        captures:
          1:
            name: punctuation.definition.variable
          2:
            name: variable.other
          3:
            name: punctuation.definition.variable

  stringType:
    patterns:
      - # Handle strings in an statement
        match: (\S*?)('.*?')(.*)
        captures:
          1:
            # This group refers to an statement operator
            name: keyword.control.jcl
            patterns:
              - include: "#additionaljclHighlight"
          2:
            #  A string was found, so we can't be sure this is the end of
            #  the line
            name: string.quoted.single.jcl
          3:
            # Recursively call this rule to get all patterns.
            patterns:
              - include: "#jclArguments"
  labels:
    # marks labels in the code
    match: ".*"
    name: entity.name.function.jcl
  operators:
    # marks operators properly
    match: "[=(),+]"
    name: keyword.operator.jcl
  numbers:
    # marks numbers properly
    match: "(?<=[=(),*\\s+])-?\\d*(?=[=(),*+\\s]|$)"
    name: constant.numeric.jcl
  sequenceNumbers:
    name: constant.numeric.jcl
    match: ".*"
scopeName: source.jcl
